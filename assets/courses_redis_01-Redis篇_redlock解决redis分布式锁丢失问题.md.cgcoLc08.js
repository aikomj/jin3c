import{_ as e}from"./chunks/ArticleMetadata.MTmQQbJH.js";import{_ as k,D as p,o as n,c as r,I as d,w as g,k as t,a as o,R as A,b as D,e as c}from"./chunks/framework.sNq7zgZB.js";import"./chunks/md5.OmtLykJF.js";const y="/jin3c/assets/distribute-lock-redis-cluster.OiRwwyuv.png",F="/jin3c/assets/distribute-lock-redis-cluster-2.uA3guf3l.png",S=JSON.parse('{"title":"Redlock解决redis分布式锁丢失的问题","description":"","frontmatter":{"title":"Redlock解决redis分布式锁丢失的问题","author":"谨三思","date":"2025/04/02 10:00","isTop":false,"categories":["Redis篇"],"tags":["分布式锁"]},"headers":[],"relativePath":"courses/redis/01-Redis篇/redlock解决redis分布式锁丢失问题.md","filePath":"courses/redis/01-Redis篇/redlock解决redis分布式锁丢失问题.md","lastUpdated":1743655080000}'),C={name:"courses/redis/01-Redis篇/redlock解决redis分布式锁丢失问题.md"},u=t("h1",{id:"redlock解决redis分布式锁丢失的问题",tabindex:"-1"},[o("Redlock解决redis分布式锁丢失的问题 "),t("a",{class:"header-anchor",href:"#redlock解决redis分布式锁丢失的问题","aria-label":'Permalink to "Redlock解决redis分布式锁丢失的问题"'},"​")],-1),B=A('<h2 id="_1、分布式锁redlock-redisson" tabindex="-1">1、分布式锁Redlock+Redisson <a class="header-anchor" href="#_1、分布式锁redlock-redisson" aria-label="Permalink to &quot;1、分布式锁Redlock+Redisson&quot;">​</a></h2><p><img src="'+y+'" alt=""></p><h3 id="问题" tabindex="-1">问题 <a class="header-anchor" href="#问题" aria-label="Permalink to &quot;问题&quot;">​</a></h3><p>如果线程一在Redis的master节点上拿到了锁，但是加锁的key还没同步到slave节点。恰好这时，master节点发生故障，一个slave节点就会升级为master节点。线程二就可以获取同个key的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。</p><p>事实上这类琐最大的缺点就是它加锁时只作用在一个Redis节点上，即使Redis通过sentinel保证高可用，如果这个master节点由于某些原因发生了主从切换，那么就会出现锁丢失的情况：</p><ol><li>在Redis的master节点上拿到了锁；</li><li>但是这个加锁的key还没有同步到slave节点；</li><li>master故障，发生故障转移，slave节点升级为master节点；</li><li>导致锁丢失。</li></ol><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><p>为了解决这个问题，Redis作者 antirez提出一种高级的分布式锁算法：Redlock。</p><p>Redlock核心思想是这样的：</p><blockquote><p>搞多个Redis master部署，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。</p></blockquote><p>我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例</p><p><img src="'+F+`" alt=""></p><p>RedLock的实现步骤，如下：</p><ol><li><p>获取当前时间，以毫秒为单位。</p></li><li><p>按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。</p></li><li><p>客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&gt; 30ms+40ms+50ms+4m0s+50ms）</p></li><li><p>如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。</p></li><li><p>如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。</p></li></ol><p>简化下步骤就是：</p><ul><li>按顺序向5个master节点请求加锁</li><li>根据设置的超时时间来判断，是不是要跳过该master节点。</li><li>如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。</li><li>如果获取锁失败，解锁！</li></ul><p>Redisson实现了redLock版本的锁，有兴趣的小伙伴，可以去了解一下哈~</p><p><mark>redisson已经有对redlock算法封装，接下来对其用法进行简单介绍，并对核心源码进行分析（假设5个redis实例）。</mark></p><p>redisson的pom依赖</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;org.redisson&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">groupId</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;redisson&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">artifactId</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;3.3.2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">version</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">dependency</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p>首先，我们来看一下redission封装的redlock算法实现的分布式锁用法，非常简单，跟重入锁（ReentrantLock）有点类似：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Config</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> Config</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">config.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">useSentinelServers</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addSentinelAddress</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;127.0.0.1:6369&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;127.0.0.1:6379&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;127.0.0.1:6389&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setMasterName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;masterName&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setPassword</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;password&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">setDatabase</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">RedissonClient</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> redissonClient</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> Redisson.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(config);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 还可以getFairLock(), getReadWriteLock()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">RLock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> redLock</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> redissonClient.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getLock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;REDLOCK_KEY&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">boolean</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> isLock;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">try</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    isLock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> redLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">tryLock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 500ms拿不到锁, 就认为获取锁失败。10000ms即10s是锁失效时间。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    isLock </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> redLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">tryLock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">500</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">10000</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, TimeUnit.MILLISECONDS);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (isLock) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">        //TODO if get lock success, do something;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (Exception </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">finally</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 无论如何, 最后都要解锁</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    redLock.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">unlock</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h3 id="唯一id" tabindex="-1">唯一ID <a class="header-anchor" href="#唯一id" aria-label="Permalink to &quot;唯一ID&quot;">​</a></h3><p>实现分布式锁的一个非常重要的点就是set的value要具有唯一性，redisson的value是怎样保证value的唯一性呢？答案是<strong>UUID+threadId</strong>。入口在redissonClient.getLock(&quot;REDLOCK_KEY&quot;)，源码在Redisson.java和RedissonLock.java中：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">protected</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> final</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> UUID</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> UUID.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">randomUUID</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">String </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getLockName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> threadId) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;:&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> threadId;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h3 id="获取锁" tabindex="-1">获取锁 <a class="header-anchor" href="#获取锁" aria-label="Permalink to &quot;获取锁&quot;">​</a></h3><p>获取锁的代码为redLock.tryLock()或者redLock.tryLock(500, 10000, TimeUnit.MILLISECONDS)，两者的最终核心源码都是下面这段代码，只不过前者获取锁的默认租约时间（leaseTime）是LOCK_EXPIRATION_INTERVAL_SECONDS，即30s：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> RFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> tryLockInnerAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> leaseTime, TimeUnit unit, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> threadId, RedisStrictCommand</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> command) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    internalLockLeaseTime </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> unit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">toMillis</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(leaseTime);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 获取锁时向5个redis实例发送的命令</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> commandExecutor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">evalWriteAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(), LongCodec.INSTANCE, command,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">              // 首先分布式锁的KEY不能存在，如果确实不存在，那么执行hset命令（hset REDLOCK_KEY uuid+threadId 1），并通过pexpire设置失效时间（也是锁的租约时间）</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">              &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                  &quot;redis.call(&#39;hset&#39;, KEYS[1], ARGV[2], 1); &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                  &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                  &quot;return nil; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">              &quot;end; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">              // 如果分布式锁的KEY已经存在，并且value也匹配，表示是当前线程持有的锁，那么重入次数加1，并且设置失效时间</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">              &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[2]) == 1) then &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                  &quot;redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[2], 1); &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                  &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[1]); &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                  &quot;return nil; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">              &quot;end; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">              // 获取分布式锁的KEY的失效时间毫秒数</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">              &quot;return redis.call(&#39;pttl&#39;, KEYS[1]);&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">              // 这三个参数分别对应KEYS[1]，ARGV[1]和ARGV[2]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                Collections.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Object</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">singletonList</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()), internalLockLeaseTime, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getLockName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(threadId));</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>获取锁的命令中，</p><ul><li>**KEYS[1]**就是Collections.singletonList(getName())，表示分布式锁的key，即REDLOCK_KEY；</li><li>**ARGV[1]**就是internalLockLeaseTime，即锁的租约时间，默认30s；</li><li>**ARGV[2]**就是getLockName(threadId)，是获取锁时set的唯一值，即UUID+threadId：</li></ul><h3 id="释放锁" tabindex="-1">释放锁 <a class="header-anchor" href="#释放锁" aria-label="Permalink to &quot;释放锁&quot;">​</a></h3><p>释放锁的代码为redLock.unlock()，核心源码如下：</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">protected</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> RFuture</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Boolean</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> unlockInnerAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">long</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> threadId) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 向5个redis实例都执行如下命令</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> commandExecutor.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">evalWriteAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">            // 如果分布式锁KEY不存在，那么向channel发布一条消息</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">            &quot;if (redis.call(&#39;exists&#39;, KEYS[1]) == 0) then &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                &quot;return 1; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">            &quot;end;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">            // 如果分布式锁存在，但是value不匹配，表示锁已经被占用，那么直接返回</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">            &quot;if (redis.call(&#39;hexists&#39;, KEYS[1], ARGV[3]) == 0) then &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                &quot;return nil;&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">            &quot;end; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">            // 如果就是当前线程占有分布式锁，那么将重入次数减1</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">            &quot;local counter = redis.call(&#39;hincrby&#39;, KEYS[1], ARGV[3], -1); &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">            // 重入次数减1后的值如果大于0，表示分布式锁有重入过，那么只设置失效时间，还不能删除</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">            &quot;if (counter &gt; 0) then &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                &quot;redis.call(&#39;pexpire&#39;, KEYS[1], ARGV[2]); &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                &quot;return 0; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">            &quot;else &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">                // 重入次数减1后的值如果为0，表示分布式锁只获取过1次，那么删除这个KEY，并发布解锁消息</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                &quot;redis.call(&#39;del&#39;, KEYS[1]); &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                &quot;redis.call(&#39;publish&#39;, KEYS[2], ARGV[1]); &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">                &quot;return 1; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">            &quot;end; &quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">            &quot;return nil;&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">            // 这5个参数分别对应KEYS[1]，KEYS[2]，ARGV[1]，ARGV[2]和ARGV[3]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            Arrays.</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">Object</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">asList</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(), </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getChannelName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()), LockPubSub.unlockMessage, internalLockLeaseTime, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getLockName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(threadId));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p><strong>参考：</strong></p><p>[1] <strong>redis系列：分布式锁:</strong> <a href="https://juejin.cn/post/6844903656911798285" target="_blank" rel="noreferrer">https://juejin.cn/post/6844903656911798285</a></p><p>[2] <strong>浅析 Redis 分布式锁解决方案:</strong> <a href="https://www.infoq.cn/article/dvaaj71f4fbqsxmgvdce" target="_blank" rel="noreferrer">https://www.infoq.cn/article/dvaaj71f4fbqsxmgvdce</a></p><p>[3] <strong>细说Redis分布式锁</strong> <a href="https://juejin.cn/post/6844904082860146695#heading-3" target="_blank" rel="noreferrer">https://juejin.cn/post/6844904082860146695#heading-3</a></p>`,37);function E(s,m,q,R,_,v){const l=e,h=p("ClientOnly");return n(),r("div",null,[u,d(h,null,{default:g(()=>{var i,a;return[(((i=s.$frontmatter)==null?void 0:i.aside)??!0)&&(((a=s.$frontmatter)==null?void 0:a.showArticleMetadata)??!0)?(n(),D(l,{key:0,article:s.$frontmatter},null,8,["article"])):c("",!0)]}),_:1}),B])}const I=k(C,[["render",E]]);export{S as __pageData,I as default};
